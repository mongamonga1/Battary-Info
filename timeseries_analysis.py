# -*- coding: utf-8 -*-
"""Timeseries anlaysis

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1N3-VI1DrTc_SGqyI1D--9lQIvDzTNDbZ
"""

import numpy as np
import pandas as pd
import os
import matplotlib.pyplot as plt
import seaborn as sns

# 한글 세팅

# 1. 나눔고딕 폰트 설치
!apt-get -qq update
!apt-get -qq install -y fonts-nanum

# 2. 런타임에 폰트 캐시 갱신
import matplotlib.font_manager as fm
import matplotlib.pyplot as plt
import matplotlib as mpl

font_dirs = ['/usr/share/fonts/truetype/nanum']
font_files = fm.findSystemFonts(fontpaths=font_dirs)

for font_file in font_files:
    fm.fontManager.addfont(font_file)

# 3. 폰트 이름 확인 후 설정
nanum_font_name = fm.FontProperties(fname=font_files[0]).get_name()
print(f"설정된 폰트 이름: {nanum_font_name}")

# matplotlib에 폰트 반영
mpl.rcParams['font.family'] = 'NanumGothic'
mpl.rcParams['axes.unicode_minus'] = False

import warnings
from collections import defaultdict
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.holtwinters import ExponentialSmoothing

warnings.filterwarnings('ignore')
plt.rcParams['font.family'] = 'DejaVu Sans'  # 시스템에 맞춰 조정

# (b) 한글용 Nanum 폰트 지정
mpl.rcParams['font.family'] = 'NanumGothic'
mpl.rcParams['axes.unicode_minus'] = False

# ────────────────────────────────────────────────
# 1) 데이터 로드 & 기본 설정

df = pd.read_csv('/content/통합거래내역 (3).csv', parse_dates=['계약일'])

battery_types = ['코나', '아이오닉', '니로']
forecast_horizon = 12  # 예측 개월 수
color_map = {
    '코나': 'tab:blue',
    '아이오닉': 'tab:orange',
    '니로': 'tab:green',
}

# ────────────────────────────────────────────────
# 2) 월별 통계 계산 & 예측 준비
monthly_stats_dict = {}
forecast_dict = {}
future_idx_dict = {}

for batt in battery_types:
    df_bt = df[df['배터리 종류'] == batt].copy()
    if df_bt.empty:
        print(f'[경고] "{batt}" 데이터가 없습니다. 그래프에서 제외됩니다.')
        continue

    # 월별 최저/최고/평균
    monthly_stats = (
        df_bt.set_index('계약일')['총 계약금액']
        .resample('M')
        .agg(['min', 'max', 'mean'])
        .dropna()
    )
    monthly_stats_dict[batt] = monthly_stats

    # Holt‑Winters 예측(데이터가 24개월 이상일 때)
    if len(monthly_stats) >= 24:
        model = ExponentialSmoothing(
            monthly_stats['mean'],
            trend='add',
            seasonal='add',
            seasonal_periods=12,
        )
        fit = model.fit()
        future_idx = pd.date_range(
            start=monthly_stats.index[-1] + pd.offsets.MonthBegin(1),
            periods=forecast_horizon,
            freq='M',
        )
        forecast = fit.forecast(forecast_horizon)
        forecast_dict[batt] = forecast
        future_idx_dict[batt] = future_idx
    else:
        print(f'[안내] "{batt}" 데이터가 24개월 미만이라 예측을 생략했습니다.')

# ────────────────────────────────────────────────
# 3) 그래프 1 — 세 배터리 월평균 + 예측 한 화면
fig1, ax1 = plt.subplots(figsize=(14, 6))

for batt, stats in monthly_stats_dict.items():
    ax1.plot(
        stats.index,
        stats['mean'],
        marker='o',
        label=f'{batt} 월평균',
        color=color_map.get(batt),
    )
    if batt in forecast_dict:
        ax1.plot(
            future_idx_dict[batt],
            forecast_dict[batt],
            linestyle='--',
            marker='o',
            label=f'{batt} 예측',
            color=color_map.get(batt),
        )

ax1.set_title('배터리 종류별 월평균 시세 & 12개월 예측', fontsize=16, fontweight='bold')
ax1.set_xlabel('기간')
ax1.set_ylabel('가격')
ax1.grid(True)
ax1.legend()

import matplotlib.ticker as mtick      # 파일 맨 위에 이미 있다면 생략
ax1.yaxis.set_major_formatter(mtick.ScalarFormatter(useMathText=False))
ax1.ticklabel_format(axis='y', style='plain')   # 지수표기 끄기

fig1.autofmt_xdate()
plt.tight_layout()
plt.show()

# ────────────────────────────────────────────────
# 4) 그래프 2 — 배터리별 최저·최고·평균 범위(error‑bar)
for batt, stats in monthly_stats_dict.items():
    fig2, ax2 = plt.subplots(figsize=(12, 6))
    ax2.errorbar(
        stats.index,
        stats['mean'],
        yerr=[
            stats['mean'] - stats['min'],
            stats['max'] - stats['mean'],
        ],
        fmt='o',
        ecolor='gray',
        capsize=4,
        color=color_map.get(batt, 'darkorange'),
        label='평균 ± (최저↔최고)',
    )
    ax2.set_title(f'{batt} 배터리 월별 시세 범위 (최저·평균·최고)', fontsize=16, fontweight='bold')
    ax2.set_xlabel('기간')
    ax2.set_ylabel('가격')
    ax2.grid(True)
    ax2.legend()
    ax2.yaxis.set_major_formatter(mtick.ScalarFormatter(useMathText=False))
    ax2.ticklabel_format(axis='y', style='plain')

    fig2.autofmt_xdate()
    plt.tight_layout()
    plt.show()

import warnings
from collections import defaultdict

import pandas as pd
import plotly.graph_objs as go
from plotly.subplots import make_subplots
from statsmodels.tsa.holtwinters import ExponentialSmoothing

warnings.filterwarnings("ignore")

# ────────────────────────────────────────────────
# 1) 데이터 로드 & 설정
file_path = "/content/통합거래내역 (3).csv"  # ← CSV 위치

df = pd.read_csv(file_path, parse_dates=["계약일"])

battery_types = ["코나", "아이오닉", "니로"]
forecast_horizon = 12
color_map = {
    "코나": "#1f77b4",      # blue
    "아이오닉": "#ff7f0e",  # orange
    "니로": "#2ca02c",      # green
}

# ────────────────────────────────────────────────
# 2) 월별 통계 & 예측 계산
monthly_stats_dict, forecast_dict, future_idx_dict = {}, {}, {}

for batt in battery_types:
    df_bt = df[df["배터리 종류"] == batt].copy()
    if df_bt.empty:
        print(f"[경고] '{batt}' 데이터가 없습니다 – 제외됩니다.")
        continue

    monthly_stats = (
        df_bt.set_index("계약일")["개당 가격"].resample("M").agg(["min", "max", "mean"]).dropna()
    )
    monthly_stats_dict[batt] = monthly_stats

    # 예측(24개월 이상일 때만)
    if len(monthly_stats) >= 24:
        model = ExponentialSmoothing(
            monthly_stats["mean"], trend="add", seasonal="add", seasonal_periods=12
        )
        fit = model.fit()
        future_idx = pd.date_range(
            start=monthly_stats.index[-1] + pd.offsets.MonthBegin(1),
            periods=forecast_horizon,
            freq="M",
        )
        forecast_dict[batt] = fit.forecast(forecast_horizon)
        future_idx_dict[batt] = future_idx
    else:
        print(f"[안내] '{batt}' 데이터 24개월 미만 → 예측 생략.")

# ────────────────────────────────────────────────
# 3) Plotly 그래프 1: 월평균 + 예측 (전체 비교)
fig1 = go.Figure()

for batt, stats in monthly_stats_dict.items():
    # 실제 월평균
    fig1.add_trace(
        go.Scatter(
            x=stats.index,
            y=stats["mean"],
            mode="lines+markers",
            name=f"{batt} 월평균",
            line=dict(color=color_map.get(batt)),
        )
    )
    # 예측 (점선)
    if batt in forecast_dict:
        fig1.add_trace(
            go.Scatter(
                x=future_idx_dict[batt],
                y=forecast_dict[batt],
                mode="lines+markers",
                name=f"{batt} 예측",
                line=dict(color=color_map.get(batt), dash="dash"),
            )
        )

fig1.update_layout(
    title="배터리 종류별 월평균 시세 & 12개월 예측 (클릭으로 토글)",
    xaxis_title="기간",
    yaxis_title="가격",
    hovermode="x unified",
)
fig1.update_yaxes(tickformat=",")  # 10000000 → 10,000,000 표시

fig1.show()

# ────────────────────────────────────────────────
# 4) Plotly 그래프 2: 최저·평균·최고(에러바) — 드롭다운
fig2 = go.Figure()
visible_flags = []   # 각 trace의 초기 visible 여부 관리
buttons = []

for i, batt in enumerate(battery_types):
    stats = monthly_stats_dict.get(batt)
    if stats is None:
        continue

    # 에러바 trace 추가 (처음 것만 보이도록)
    visible = True if i == 0 else False
    visible_flags.append(visible)

    fig2.add_trace(
        go.Scatter(
            x=stats.index,
            y=stats["mean"],
            mode="markers",
            error_y=dict(
                type="data",
                symmetric=False,
                array=stats["max"] - stats["mean"],
                arrayminus=stats["mean"] - stats["min"],
                thickness=1.5,
                width=4,
            ),
            marker=dict(color=color_map.get(batt, "darkorange"), size=8),
            name=batt,
            visible=visible,
        )
    )

# 드롭다운 버튼 생성
for idx, batt in enumerate(battery_types):
    # 버튼 클릭 시 idx 번째 trace만 visible
    vis = [False] * len(battery_types)
    if idx < len(vis):
        vis[idx] = True
    buttons.append(
        dict(
            label=batt,
            method="update",
            args=[{"visible": vis}, {"title": f"{batt} 배터리 월별 시세 범위 (최저·평균·최고)"}],
        )
    )

fig2.update_layout(
    title=f"{battery_types[0]} 배터리 월별 시세 범위 (최저·평균·최고)",
    xaxis_title="기간",
    yaxis_title="가격",
    updatemenus=[
        dict(
            type="dropdown",
            x=1.15,
            y=0.5,
            showactive=True,
            buttons=buttons,
        )
    ],
)
fig2.update_yaxes(tickformat=",")
fig2.show()

import warnings
import pandas as pd
import plotly.graph_objs as go
from statsmodels.tsa.holtwinters import ExponentialSmoothing
from itertools import cycle

warnings.filterwarnings("ignore")

# ────────────────────────────────────────────────
# 1) 데이터 로드 & 기본 설정
df = pd.read_csv('/content/통합거래내역 (3).csv', parse_dates=["계약일"])

product_types = sorted(df["제품 구분"].dropna().unique())  # CSV에 존재하는 5종 자동 인식
forecast_horizon = 12

# Plotly 기본 팔레트에서 색 5개 순환
palette = cycle(["#1f77b4", "#ff7f0e", "#2ca02c", "#d62728", "#9467bd", "#8c564b"])
color_map = {ptype: next(palette) for ptype in product_types}

# ────────────────────────────────────────────────
# 2) 월별 통계 & 예측 계산
monthly_stats_dict = {}
forecast_dict = {}
future_idx_dict = {}

for ptype in product_types:
    df_p = df[df["제품 구분"] == ptype].copy()
    if df_p.empty:
        continue

    monthly_stats = (
        df_p.set_index("계약일")["개당 가격"]
            .resample("M")
            .agg(["min", "max", "mean"])
            .dropna()
    )
    monthly_stats_dict[ptype] = monthly_stats

    # 예측: 24개월 이상 데이터만
    if len(monthly_stats) >= 24:
        model = ExponentialSmoothing(
            monthly_stats["mean"], trend="add", seasonal="add", seasonal_periods=12
        )
        fit = model.fit()
        future_idx = pd.date_range(
            start=monthly_stats.index[-1] + pd.offsets.MonthBegin(1),
            periods=forecast_horizon,
            freq="M",
        )
        forecast_dict[ptype] = fit.forecast(forecast_horizon)
        future_idx_dict[ptype] = future_idx

# ────────────────────────────────────────────────
# 3) 그래프 1: 월평균 + 예측 (전체 비교)
fig1 = go.Figure()

for ptype, stats in monthly_stats_dict.items():
    color = color_map.get(ptype)
    # 실제 월평균
    fig1.add_trace(
        go.Scatter(
            x=stats.index,
            y=stats["mean"],
            mode="lines+markers",
            name=f"{ptype} 월평균",
            line=dict(color=color),
        )
    )
    # 예측
    if ptype in forecast_dict:
        fig1.add_trace(
            go.Scatter(
                x=future_idx_dict[ptype],
                y=forecast_dict[ptype],
                mode="lines+markers",
                name=f"{ptype} 예측",
                line=dict(color=color, dash="dash"),
        )
    )

fig1.update_layout(
    title="제품 구분별 월평균 시세 & 12개월 예측 (범례 클릭으로 토글)",
    xaxis_title="기간",
    yaxis_title="가격",
    hovermode="x unified",
)
fig1.update_yaxes(tickformat=",")
fig1.show()

# ────────────────────────────────────────────────
# 4) 그래프 2: 최저·평균·최고(error‑bar) — 드롭다운
fig2 = go.Figure()
buttons = []

# trace 추가 (모두 invisible, 첫 번째만 visible)
for idx, ptype in enumerate(product_types):
    stats = monthly_stats_dict.get(ptype)
    if stats is None:
        continue

    visible = True if idx == 0 else False
    fig2.add_trace(
        go.Scatter(
            x=stats.index,
            y=stats["mean"],
            mode="markers",
            error_y=dict(
                type="data",
                symmetric=False,
                array=stats["max"] - stats["mean"],
                arrayminus=stats["mean"] - stats["min"],
                width=4,
                thickness=1.5,
            ),
            marker=dict(color=color_map.get(ptype), size=8),
            name=ptype,
            visible=visible,
        )
    )

# 드롭다운 버튼
for idx, ptype in enumerate(product_types):
    vis = [False] * len(product_types)
    vis[idx] = True
    buttons.append(
        dict(
            label=ptype,
            method="update",
            args=[{"visible": vis}, {"title": f"{ptype} 월별 시세 범위 (최저·평균·최고)"}],
        )
    )

fig2.update_layout(
    title=f"{product_types[0]} 월별 시세 범위 (최저·평균·최고)",
    xaxis_title="기간",
    yaxis_title="가격",
    updatemenus=[dict(type="dropdown", x=1.15, y=0.5, buttons=buttons, showactive=True)],
)
fig2.update_yaxes(tickformat=",")
fig2.show()
